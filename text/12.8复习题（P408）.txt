1. 哪些类别的变量可以成为它所在函数的局部变量？
    块作用域，函数作用域，函数原型作用域的变量可以成为它所在函数的局部变量。

    答案：
    自动存储类别；寄存器存储类别；静态、无链接存储类别。            //答案写的确实完整一点诶？

2. 哪些类别的变量在它所在程序的运行期间一直存在？
    文件作用域，静态储存期的变量会在其程序运行期间一直存在。

3. 哪些类别的的变量可以被多个文件使用？哪些类别的变量仅限于在一个文件中使用？
    外部链接类型的变量可以被多个文件使用，内部链接类型的变量仅限于一个文件内使用。

4. 块作用域变量具有什么链接属性？
    无链接。
    
5. extern关键字有什么用途？
    在函数外定义，可以声明变量在另一个文件内已定义，此处只是引用是声明。
    在函数内使用extern关键词显式地表明此变量为文件作用域变量。


6. 考虑下面两行代码，就输出的结果而言有何异同？
    int * p1 = (int *) malloc(100 * sizeof(int));
    int * p2 = (int *) calloc(100, sizeof(int));

    p1指向一片连续的内存的第一个地址，该内存总共占用100个int类型大小。
    p2指向一百个单位的内存的第一个地址，每个单位占用1个int类型大小。


7. 下面的变量对哪些函数可见？程序是否有误？
    /*文件1*/
    int daisy;
    int main(void)
    {
        int lily;
        ...;
    }
    int petal()
    {
        extern int daisy, lily;
        ...;
    }

    /*文件2*/
    extern int daisy;
    static int lily;
    int rose;
    int stem()
    {
        int rose;
        ...;
    }
    void root()
    {
        ...;
    }

    文件1中，daisy对所有函数都可见，lily仅main函数内可见。petal函数中引用式声明的lily并不对其可见。
    文件2中，static内部链接类型的lily仅文件2中可见，与main函数中的lily变量虽然名称相同，但是不是同一个变量。
    rose对所有函数都可见。

8. 下面的程序会打印什么？
    #include <stdio.h>
    char color = 'B';
    void first(void);
    void second(void);

    int main(void)
    {
        extern char color;

        printf("color in main() is %c\n", color);
        first();
        printf("color in main() is %c\n", color);
        second();
        printf("color in main() is %c\n", color);
        return 0;
    }

    void first(void)
    {
        char color;

        color = 'R';
        printf("color in first() is %c\n", color);
    }

    void second(void)
    {
        color = 'G';
        printf("color in second() is %c\n", color);
    }

    输出如下：
    color in main() is B
    color in first() is R
    color in main() is B            //first函数中color的定义没用extern关键字，可能会创建一个新的变量
    color in second() is G
    color in main() is G
    
9. 假设文件的开始处有如下声明：
    static int plink;
    int value_ct(const int arr[], int value, int n);

    a. 以上声明表明了程序员的什么意图？
    b. 用const int value和const int n分别替换int value和int n，是否对主调程序的值加强保护。

    a. static int plink 表明变量plink具有内部链接性质。
       value_ct的函数原型表明value_ct函数不会修改作为参数传入的数组。
    b. 不一定，比如我这种菜鸡就喜欢用函数传入的参数作为循环的变量..可能不能起到什么保护作用。