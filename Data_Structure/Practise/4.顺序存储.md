一、选择题

1. 下述（ ）是顺序存储结构的优点

   A. 存储密度大

   B. 插入运算方便

   C. 删除运算方便

   D. 方便的运用与各种逻辑结构的存储表示

   选A。顺序表查找方便，但插入删除都不方便。B、C错误。D显然错误，对于树等数据结构，顺序表显然不如链表方便。



2. 线性表的顺序存储结构是一种（ ）

   A. 随机存取的存储结构
   B. 顺序存取的存储结构

   C. 索引存取的存储结构

   D. 散列存取的存储结构

   选A。存取方式指的是读写方式，顺序表是一种支持随机存储的存储结构。



3. 一个顺序表所占用的存储空间大小与（ ）无关

   A. 表的长度

   B. 元素的存放顺序

   C. 元素的类型

   D. 元素中各字段的类型

   选B。顺序表所占存储空间 = 表长 × sizeof(元素类型)。



4. 若线性表最常用的操作是存取第 i 个元素及其前驱和后继元素的值，为了提高效率，用（ ）存储方式可以节省时间。

   A. 单链表

   B. 双向链表

   C. 单循环链表

   D. 顺序表

   选D。顺序表支持随机存取，只需给出元素在表中的位序可以直接计算出其前驱和后继元素的值。



5. 一个线性表最常用的操作是存取任意指定序号的元素并在最后进行插入、删除操作，则利用（ ）存储方式可以节省时间。

   A. 顺序表

   B. 双链表

   C. 带头结点的双循环链表

   D. 单循环链表

   选A。顺序表支持随机存取，且在表的最后进行插入删除操作不需要移动任何元素。



6. 在n个元素的线性表的数组表示中，时间复杂度为O(1)的操作是（ ）

   A. 访问第 i （1 <= i <= n）个结点和求第 i （2 <= i <= n）个结点的直接前驱。

   B. 在最后一个结点后插入一个新的结点
   C. 删除第1个结点

   D. 在第 i （1 <= i <= n)个结点后插入一个结点

   选AB。



7. 设线性表有n个元素，严格来说，以下操作中，（ ）在顺序表上实现要比在链表上实现的效率高。

   A. 输出第 i （1 <= i <= n）个元素值

   B. 交换第3个元素与第4个元素的值

   C. 顺序输出这n个元素的值

   选AB。在顺序表中交换两元素的值仅需三次赋值操作即可完成，在链表中，要么交换整个结点，要么交换节点中的值，都需要找到前驱结点，效率较低。



8. 在一个长度为n的顺序表中删除第 i（1 <= i <= n）个元素时，须向前移动（ ）个元素。

   A. n	B. n-1	C. n-i	D. n-i+1

   选C。需要将$a_{i+1}$~$a_{n}$个元素向前移动，因此需要移动$n-(i+1)+1 = n-i$个元素。



9. 对于顺序表，访问第 i 个元素和在第 i 个位置插入一个元素的时间复杂度为（ ）

   A. O(n), O(n)	B. O(n), O(1)	C. O(1), O(n)	D. O(1), O(1)

   选C。在第 i 个位置插入元素需移动n-i+1个元素，时间复杂度为O(n)。



10. 若长度为n的非空线性表采用顺序存储结构，在表的第 i 个位置插入一个数据元素，则 i 的合法值应该是（ ）

    A. 1 <= i <= n		B. 1 <= i <= n+1		C. 0 <= i <= n-1		D. 0 <= i <= n

    选B。线性表的序号是从1开始的，在n+1的位置插入即在表尾插入。



11. 顺序表的插入算法中，当n个空间已满时，可再申请增加分配m个空间，若申请失败，则说明系统没有（ ）可分配的存储空间

    A. m个

    B. m个连续

    C. n+m个

    D. n+m个连续

    选D。



二、综合题

1. 从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值，空出的位置有最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。

   ```C
   Elemtype DeleteMinElem(SqList *list)			// 删除最小元素，并返回删除的最小元素
   {
       if (list->length == 0)						// 如果线性表为空则提示错误并退出运行。
       {
           printf("顺序表为空。\n");
           exit(1);
       }
       
       Elemtype min = list->arr[0];				// 默认最小元素为第一个元素。
       int pos = 0;
       for (int i = 0; i < list->length; i++)		// 找到最小元素，并用min记录最小元素值，pos记录元素索引值
       {
           if (list->arr[i] < min)
           {
               min = list->arr[i];
               pos = i;
           }
       }
       list->arr[pos] = list->arr[list->legnth-1];	// 将删除元素用表尾元素填充。
       list->length--;								// 表长减一
       return min;									// 返回被删除的最小值。
   }
   ```