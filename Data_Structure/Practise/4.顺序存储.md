一、选择题

1. 下述（ ）是顺序存储结构的优点

   A. 存储密度大

   B. 插入运算方便

   C. 删除运算方便

   D. 方便的运用与各种逻辑结构的存储表示

   选A。顺序表查找方便，但插入删除都不方便。B、C错误。D显然错误，对于树等数据结构，顺序表显然不如链表方便。



2. 线性表的顺序存储结构是一种（ ）

   A. 随机存取的存储结构
   B. 顺序存取的存储结构

   C. 索引存取的存储结构

   D. 散列存取的存储结构

   选A。存取方式指的是读写方式，顺序表是一种支持随机存储的存储结构。



3. 一个顺序表所占用的存储空间大小与（ ）无关

   A. 表的长度

   B. 元素的存放顺序

   C. 元素的类型

   D. 元素中各字段的类型

   选B。顺序表所占存储空间 = 表长 × sizeof(元素类型)。



4. 若线性表最常用的操作是存取第 i 个元素及其前驱和后继元素的值，为了提高效率，用（ ）存储方式可以节省时间。

   A. 单链表

   B. 双向链表

   C. 单循环链表

   D. 顺序表

   选D。顺序表支持随机存取，只需给出元素在表中的位序可以直接计算出其前驱和后继元素的值。



5. 一个线性表最常用的操作是存取任意指定序号的元素并在最后进行插入、删除操作，则利用（ ）存储方式可以节省时间。

   A. 顺序表

   B. 双链表

   C. 带头结点的双循环链表

   D. 单循环链表

   选A。顺序表支持随机存取，且在表的最后进行插入删除操作不需要移动任何元素。



6. 在n个元素的线性表的数组表示中，时间复杂度为O(1)的操作是（ ）

   A. 访问第 i （1 <= i <= n）个结点和求第 i （2 <= i <= n）个结点的直接前驱。

   B. 在最后一个结点后插入一个新的结点
   C. 删除第1个结点

   D. 在第 i （1 <= i <= n)个结点后插入一个结点

   选AB。



7. 设线性表有n个元素，严格来说，以下操作中，（ ）在顺序表上实现要比在链表上实现的效率高。

   A. 输出第 i （1 <= i <= n）个元素值

   B. 交换第3个元素与第4个元素的值

   C. 顺序输出这n个元素的值

   选AB。在顺序表中交换两元素的值仅需三次赋值操作即可完成，在链表中，要么交换整个结点，要么交换节点中的值，都需要找到前驱结点，效率较低。



8. 在一个长度为n的顺序表中删除第 i（1 <= i <= n）个元素时，须向前移动（ ）个元素。

   A. n	B. n-1	C. n-i	D. n-i+1

   选C。需要将$a_{i+1}$~$a_{n}$个元素向前移动，因此需要移动$n-(i+1)+1 = n-i$个元素。



9. 对于顺序表，访问第 i 个元素和在第 i 个位置插入一个元素的时间复杂度为（ ）

   A. O(n), O(n)	B. O(n), O(1)	C. O(1), O(n)	D. O(1), O(1)

   选C。在第 i 个位置插入元素需移动n-i+1个元素，时间复杂度为O(n)。



10. 若长度为n的非空线性表采用顺序存储结构，在表的第 i 个位置插入一个数据元素，则 i 的合法值应该是（ ）

    A. 1 <= i <= n		B. 1 <= i <= n+1		C. 0 <= i <= n-1		D. 0 <= i <= n

    选B。线性表的序号是从1开始的，在n+1的位置插入即在表尾插入。



11. 顺序表的插入算法中，当n个空间已满时，可再申请增加分配m个空间，若申请失败，则说明系统没有（ ）可分配的存储空间

    A. m个

    B. m个连续

    C. n+m个

    D. n+m个连续

    选D。



二、综合题

1. 从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值，空出的位置有最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。

   ```C
   Elemtype DeleteMinElem(SqList *list)			// 删除最小元素，并返回删除的最小元素
   {
       if (list->length == 0)						// 如果线性表为空则提示错误并退出运行。
       {
           printf("顺序表为空。\n");
           exit(1);
       }
       
       Elemtype min = list->arr[0];				// 默认最小元素为第一个元素。
       int pos = 0;
       for (int i = 0; i < list->length; i++)		// 找到最小元素，并用min记录最小元素值，pos记录元素索引值
       {
           if (list->arr[i] < min)
           {
               min = list->arr[i];
               pos = i;
           }
       }
       list->arr[pos] = list->arr[list->legnth-1];	// 将删除元素用表尾元素填充。
       list->length--;								// 表长减一
       return min;									// 返回被删除的最小值。
   }
   ```



2. 设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)。

   ```C
   // 算法思想：顺序表前半部分与后半部分对应元素交换
   void ReverseSqList(SqList *list)
   {
       Elemtype temp;
       for (int i = 0; i < list->length/2; i++)
       {
           temp = list->arr[i];
           list->arr[i] = list->arr[list->length-i-1];
           list->arr[list->length-i-1] = temp;
       }
   }
   ```



3. 对长度为n的顺序表L，编写一个时间复杂度为O(n)，空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素。

   ```C
   // 解法1
   // 用变量k统计不为x的数量，用变量i遍历顺序表
   // 相当于两个索引同时遍历，如果不为x则索引值加一，如果为x则k不变，i加一。
   void Delete_x_1(SqList *list, Elemtype x)
   {
       int k = 0;
       for (int i = 0; i < list->length; i++)
       {
           if (list->arr[i] != x)
           {
               list->arr[k] = list->arr[i];
               k++;
           }
       }
       list->length = k;
   }
   ```

   ```C
   // 解法2
   // 用变量k记录为x的元素数量，不为x的元素向前移动k个
   void Delete_x_2(SqList *list, Elemtype x)
   {
       int k = 0;
       for (int i = 0; i < list->length; i++)
       {
           if (list->arr[i] == x)
           {
               k++;
           }
           else
           {
               list->arr[i-k] = list->arr[i];
           }
       }
       list->length = list-length - k;
   }
   ```



4. 从==有序==顺序表中删除其值在给定值s与t之间（要求s < t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行。

   ```C
   // 算法思路：与上一题类似，不过本题中为有序表，因此只需找到第一个在给定值之间的元素以及第一个大于t的元素即可
   // 然后将后面部分的元素依次赋值至开始删除的地方即可。
   int Delete_S_to_T(SqList *list, Elemtype s, Elemtype t)
   {
       if (s >= t || list->length == 0)
       {
           if (list->length)
           {
               printf("The s value is not smaller than the t value.\n");
           }
           else
           {
               printf("The squence list is empty.\n");
           }
           return 0;
       }
       
       int start, end;
       for (start = 0; start < list->length; start++)
       {
           if (list->arr[start] >= s && list->arr[start] <= t)
           {
               break;
           }
       }
       // find the start index.
       
       for (end = start; end < list->length; end++)
       {
           if (list->arr[end] < s || list->arr[end] > t)
           {
               break;
           }
       }
       // find the end index.
       
       for ( ; end < list->length; end++, start++)
       {
           list->arr[start] = list->arr[end];
       }
       list->length = start;
       //list->length = list->length - (end - start);
       return 1;
   }
   ```




5. 从顺序表中删除其值在给定区间s和t之间（包含s和t，要求s<t）的所有元素，若s或t不合理，或顺序表为空，则显示错误信息并退出运行。

   ```C
   // 算法思路，先判断s和t是否合理，以及顺序表是否为空，若不满足条件则退出运行。
   // 用一个变量k记录不位于区间之间的元素数量，同时遍历顺序表，用k值做删除后的索引值，将不位于区间的值循环赋值到k值处。
   int Delete_s_to_t(SqList *list, Elemtype s, Elemtype t)
   {
       if (list->length == 0 || s >= t)
       {
           if (list->length ==  0)
           {
               printf("The sequence list is empty.\n");
           }
           else
           {
               printf("The s value is not smaller than the t value.\n");
           }
           return 0;
       }
       // 如果不符合条件则显示错误信息并退出运行
       
       
       int k = 0;
       for (int i = 0 ; i < list->legnth; i++)
       {
           if (list->arr[i] < s || list->arr[i] > t)
           {
               list->arr[k] = list->arr[i];
               k++;
           }
       }
       
       list->length = k;
       return 1;
   }
   ```

   ```C
   // 算法思路2：用变量k记录位于s与t之间元素的数量，遍历顺序表，如果不位于s和t之间则将元素前移k个位置，否则k++
   int Delete_s_to_t(SqList *list, Elemtype s, Elemtype t)
   {
       if (list->length == 0 || s >= t)
       {
           if (s >= t)
           {
               printf("The s value is not smaller than the t value.\n");
           }
           else
           {
               printf("The sequence list is empty.\n");
           }
           
           return 0;
       }
       
       int k = 0;
       for (int i = 0; i < list->length; i++)
       {
           if (list->arr[i] >= s && list->arr[i] <= t)
           {
               k++;
           }
           else
           {
               list->arr[i-k] = list->arr[i];
           }
       }
       
       list->length-= k;
       return 1;
   }
   ```



6. 从==有序==顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。

   ```C
   // 算法思路：有序顺序表，相同元素必然连续，因此用两个索引值遍历有序顺序表，第一个索引值指向0号元素，第二个索引值指向1号元素
   // 如果第二个索引值的元素与第一个索引值的元素不同，则第一个索引值自增一，将第二个索引值的元素值赋给第一个索引值的元素
   // 如果相同，则用第二个索引值继续遍历有序顺序表
   int DeleteSame(SqList *list)
   {
       if (list->length == 0)
       {
           printf("The sequence list is empty.\n");
           return 0;
       }
       
       for (int i = 0, j = 1; j < list->length; j++)
       {
           if (list->arr[i] != list->arr[j])
           {
               i++;
               list->arr[i] = list->arr[j];
           }
       }
       
       list->length =  i+1;
       return 1;
   }
   ```



7. 将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表

   ```C
   // 算法思路：先判断两个有序顺序表合并后的个数是否超过最大长度，如果超过则返回0
   // 若未超过最大长度则将两个表中的数据依次取出进行比较，存放入新表中，一个表结束后则将未结束的表剩余元素依次放入新表结尾。
   SqList* Merge(SqList *A, SqList *B)
   {
       if (A->legnth + B->length > new->maxsize)
           return NULL;
       // 若超过最大长度则返回空指针
       
       SqList *new = (SqList*)malloc(sizeof(SqList));
       // 分配新顺序表内存空间
       int i = 0, j = 0, k = 0;
       // i为A表的数组下标，j为B表的数组下标，k为新顺序表的数组下标
       while (i < A->length && j < B->length)						// 当AB的数组下标都未达到表尾时
       {															// 将两表头元素中较小的依次存入新顺序表
           if (A->arr[i] < B->arr[j])
           {
               new->arr[k] = A->arr[i];
               i++, k++;
           }
           else
           {
               new->arr[k] = B->arr[j];
               j++, k++;
           }
       }
       // 本循环中两两比较，将较小元素存入新顺序表中
       
       while (i < A->length)
       {
           new->arr[k] = A->arr[i];
           i++, k++;
       }
       while (j < B->legnth)
       {
           new->arr[k] = B->arr[j];
           j++, k++;
       }
       // 这两个循环将还剩下的元素依次存入新顺序表中
       
       new->length = k;
       // 修改新顺序表结构中的数组长度信息。
       return new;
       // 返回新顺序表指针。
   }
   ```

   

8. 已知在一维数组A[m+n]中依次存放两个线性表（a~1~, a~2~, ..., a~m~）和（b~1~, b~2~, ..., b~n~）。试编写一个函数，将数组中两个顺序表的位置互换，即将（b~1~, b~2~, ..., b~n~）放在（a~1~, a~2~, ..., a~m~）前面。

   ```C
   // 算法思路：先将数组A原地逆置（时间复杂度O(m+n)）然后将前n个逆置(时间复杂度为O(n))
   // 再将前n个（bn, bn-1, ..., b1)逆置（时间复杂度为O(n)）
   // 再将后m个（am, am-1, ..., a1)逆置（时间复杂度为O(m)）
   // 总时间复杂度为O(max(m, n)) 空间复杂度为O(1)
   
   void Reverse(Elemtype A[], int arrSize, int start, int end)
   {
       if (start >= end || arrSize <= 1)
           return;
       // 如果q起始下标与结束下标相同
       // 或数组长度小于等于1
       // 则无需逆置，直接返回
       if (end >= arrSize)
           return;
       // 如果结束下标超过或等于数组长度则认为输入错误。
       
       int mid = start + ((end-start)/2);
       // 避免整数溢出（int）
       Elemtype temp;
       for (int i = start; i <= mid; i++)
       {
           temp = A[i];
           A[i] = A[2*m - i];
           A[2*m-i] = temp;
       }
       // 将起始下标与结束下标中间的元素逆置
       return;
   }
   
   void MoveNElem(Elemtype A[], int arrSize, int m, int n)
   {
       Reverse(A, arrSize, 0, m+n-1);
       // 将数组整个逆置
       Reverse(A, arrSize, 0, n-1);
       // 将数组前n个元素逆置
       Reverse(A, arrSize, n, m+n-1);
       // 将数组后m个元素逆置
   }
   ```



9. 线性表（a~1~, a~2~, ..., a~n~）中的元素递增有序且按顺序存储与计算机内，要求设计一个算法，完成用最少的时间在表中查找数值为x的元素，若找到，则将其与后继元素位置交换，若找不到，则将其插入表中并使表中元素仍递增有序。

   ```C
   //算法思路，用二分法查找，
   void FindAndInsert(Elemtype A[], int length, Elemtype x)
{
       int left = 0, right = length-1, mid;
       while (left <= right)
       {
           mid = left + (right-left)/2;
           if (A[mid] == x)
               break;
           
           if (A[mid] < x)
           {
               left = mid + 1;
           }
           else if(A[mid] > x)
           {
               right = mid - 1;
           }
       }
       // After this while loop, A[mid] can be x or x is not in the array.
       
       if (A[mid] == x && mid != legnth - 1)
       {
           Elemtype temp = A[mid];
           A[mid] = A[mid + 1];
           A[mid + 1] = temp;
       }
       // A[mid] is x
       
       if (left > right)
       {
           for (int i = length-1; i > right; i--)
           {
               A[i+1] = A[i];
           }
           A[i] = x;
           // insert x
       }
       return;
   }
   ```
   
   

10. 设将n（n>1）个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p个位置（0<p<n），即将R中的数据由（X~0~，X~1~，...，X~n-1~）变换为（X~p~，X~p+1~，X~n-1~，X~0~，X~1~，...，X~p-1~）。要求：

    1） 给出算法的基本设计思想

    2） 根据设计思想，采用C/C++或Java语言描述算法，关键之处给出注释

    3） 说明你所设计算法的时间复杂度和空间复杂度

    1)    算法思路：把数组ab转换为ba。先将前a个元素逆置，数组变为a^-1^b，再将后b个元素逆置变为a^-1^b^-1^，再将整个数组逆置，即将整个数组变为(a^-1^b^-1^)^-1^ = ba

    2)

    ```C
    void Reverse(Elemtype A[], int start, int end)
    {
        Elemtype temp;
        int mid = start + (end-start)/2;
        for (int i = start; i <= mid; i++)
        {
            temp = A[i];
            A[i] = A[2*mid - i];
            A[2*mid - i] = temp;
        }
        return;
    }
    
    void MovePElem(Elemtype A[], int length, int p)
    {
        Reverse(A, 0, p-1);
        Reverse(A, p, length-1);
        Reverse(A, 0, length-1);
        return;
    }
    ```

    3)  复杂度分析：在将前p个元素逆置时，时间复杂度为O(p)，后n-p个元素逆置时，时间复杂度为O(n-p)，最后将整个数组逆置时，时间复杂度为O(n)，因此总时间复杂度为O(n)。算法所用辅助空间为常量，因此空间复杂度为O(1)







