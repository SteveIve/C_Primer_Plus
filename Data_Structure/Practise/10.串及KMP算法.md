一、选择题

1. 设右两个串S~1~和S~2~，求S~2~在S~1~中首次出现的位置的运算称为（ ）

   A. 求字串

   B. 判断是否相等

   C. 模式匹配

   D. 连接

   

   选C，显然。

   

2. KMP算法的特点是在模式匹配是指示主串的的指针（ ）

   A. 不会变大

   B. 不会变小

   C. 都有可能

   D. 无法判断

   

   选B，显然。

   

3. 设主串的长度为n，子串的长度为m，则简单的模式匹配算法的时间复杂度为（ ）

   A. O(m)

   B. O(n)

   C. O(mn)

   D. O(m+n)

   

   选CD。理论时间复杂度为O(mn)，一般情况下简单的模式匹配算法的时间复杂度近似为O(m+n)。

   

4. 已知串S = 'aaab'，其next数组值为（ ）

   A. 0123

   B. 0112

   C. 0231

   D. 1211

   

   选A。最大相等前后缀。

   

5. 串'ababaaababaa'的next数组值为（ ）

   A. 01234567899

   B. 012121111212

   C. 011234223456

   D. 0123012322345

   

   选C。最大相等前后缀。

   

6. 串'ababaaababaa'的next数组为（ ）

   A. -1，0，1，2，3，4，5，6，7，8，8，8

   B. -1，0，1，0，1，0，0，0，0，1，0，1

   C. -1，0，0，1，2，3，1，1，2，3，4，5

   D. -1，0，1，2，-1，0，1，2，1，1，2，3

   

   选C。如果串的位序从0开始则不需要整体加一。

   

7.  串'ababaaababaa'的nextval数组为（ ）

   A. 0，1，0，1，1，2，0，1，0，1，0，2

   B. 0，1，0，1，1，4，1，1，0，1，0，2

   C. 0，1，0，1，0，4，2，1，0，1，0，4

   D. 0，1，1，1，0，2，1，1，0，1，0，4

   

   选C。

   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |
   | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    | 3    | 4    | 5    | 6    |
   | 0    | 1    | 0    | 1    | 0    | 4    | 2    | 1    | 0    | 1    | 0    | 4    |

   先令nextval[1] = next[1] = 0，从j = 2开始，若s[j] = s[next[j]]，则nextval[j] = next[next[j]]，否则nextval[j] = next[j]。

   

8. 已知字符串S为'abaabaabacacaabaabcc'，模式串t为'abaabc'采用KMP算法进行匹配，第一次出现“失配”（s[i] != t[j]）时，i = j = 5，则下次开始匹配时，i和j的值分别是（ ）

   A. i = 1, j = 0

   B. i = 5, j = 0

   C. i = 5, j = 2

   D. i = 6, j = 2

   

   选C。由题中第一次失配时i = j = 5可知，数组下标由0开始，因此可求出nextval数组，对照数组可知下一次匹配时i=5，j=2。

   

9. 设主串T = 'abaabaabcabaabc'，模式串S = 'abaabc'，采用KMP算法进行模式匹配，到匹配成功时为止，在匹配过程中单个字符间的比较次数是( )

   A. 9

   B. 10

   C. 12

   D. 15

   

   选B。由next数组得到。

   

二、综合题

1. 在字符串模式匹配的KMP算法中，求模式的next数组值的定义如下：

   $next[j] = \left\{\begin{array}. 0, & j = 1\\max\{k|1<k<j且'p_1...p_{k-1}' = 'p_{j-k+1}...p_{j-1}'\}, &此集合不为空时\\1,&其他情况 \end{array}\right.$

   1）当j = 1时，为什么要取next[1]  = 0？

   2）为什么要取max{k}，k最大是多少？

   3）其他情况是什么情况，为什么取next[j] = 1？

   

   1）因为如果第一个元素就匹配失败时，模式串和主串的下标都应当向后移，令next[1] = 0方便函数实现。

   2）因为如果不去k能取到的最大值则有可能跳过可以匹配到模式串的字串。k最大能为k-1

   3）其他情况是除去上面两种情况外，如果发生失配情况的最坏情况令模式串从第一个元素开始重新匹配。

   

2. 设右字符串S = 'aabaabaabaac'，P = 'aabaac'。

   1）求出P的next数组

   2）若S作为主串，P作为模式串，试给出KMP算法的匹配过程。

   

   1）012123

   2）第一趟比较时，主串指针i初始为1，模式串指针初始为1。匹配至第6个元素时发生失配，由next数组可知，将j置为3，即模式串从第三个元素开始，主串从当前位置，开始第二趟匹配。

   第二趟比较时，i = 9, j = 6。由next数组，将j置为3，即模式串从第三个元素开始，主串从当前位置开始，开始第三趟匹配。

   第三趟匹配成功。