^2一个算法应该是( )

A. 程序			B. 问题求解步骤的描述		C. 要满足五个基本特性	D. A和C

选B。程序不一定满足算法的有穷性，例如操作系统， 死循环等，A错。算法的五个基本特性是算法的必要性，但不是算法的定义，C错。

算法的定义应为问题求解步骤的描述。



2. 某算法的时间复杂度为O(n^2^)，表明改算法的( )

   A. 问题规模是n^2^

   B. 执行时间等于n^2^

   C. 执行时间与n^2^成正比

   D. 问题规模与n^2^成正比

   选C。时间复杂度为O(n^2^)说明算法的时间复杂度T(n)满足T(n) <= cn^2^（c为比例常数），即T(n) = O(n^2^)。

   因此时间复杂度T(n)是==问题规模为n==的函数。



3. 以下算法的时间复杂度为( )

   ```C
   void fun(int n)
   {
       int i = 1;
       while (i < n)
           i = i * 2;
   }
   ```

   A. O(n)

   B. O(n^2^)

   C. O(nlog~2~n)

   D. O(log~2~n)

   选D。设执行次数为t，则有2^t^ <= n，即t <= log~2~n，因此时间复杂度T(n) = O(log~2~n)。



4. 设n是描述问题规模的非负整数，下面的程序片段的时间复杂度是( )

   ```C
   x = 2;
   while (x < n/2)
       x = 2 * x;
   ```

   O(log~2~n)

   设执行次数为t，则有2^t+1^ < n/2，即2^t+2^ < n，因此有t < log~2~n - 2，即T(n) = O(log~2~n)



5. 求整数n（n >= 0) 的阶乘的算法如下，求其时间复杂度

   ```C
   int fact(int n)
   {
       if (n <= 1)
           return 1;
       return n*fact(n-1);
   }
   ```

   每次函数调用的时间复杂度为O(1)，总共需要调用n次（n-1次递归调用）。因此时间复杂度为O(n)。



6. 已知两个长度分别为m和n的升序链表，若将它们合并为长度为m+n的降序链表，则最坏情况下的时间复杂度是( )

   采用头插法。两两比较两升序链表，将较小值的数据元素插入链表头，当其中一个链表结束后，将剩余元素依次插入链表头。

   因此最坏情况下，所有元素都需要进行一次插入，所以最多执行m+n次，用大O表示法即为O(max(m, n))



7. 下列程序段的时间复杂度是

   ```C
   count = 0;
   for (k = 1; k <= n; k *= 2)
       for (j = 1; j <= n; j++)
           count++;
   ```

   内层循环条件与外层变量k无关，因此各自独立，时间复杂度相乘。

   外层执行t次，即2^t^ <= n，即t <= log~2~n，外层循环时间复杂度为O(log~2~n)。

   内层显然时间复杂度为O(n)，因此该程序段的时间复杂度为O(n) * O(log~2~n) = O(nlog~2~n)



8. 下列函数的时间复杂度为

   ```C
   int func(int n)
   {
       int i = 0; sum = 0;
       while (sum < n)
           sum += ++i;
       return i;
   }
   ```

   当n = 1时，sum = 1，当n = 2时，sum = 1 + 2，设执行t次则有sum = 1 + 2 + ... + t = $(1+t) * t /2$ < n，故时间复杂度为O(n^1/2^)



9. 有以下算法，其时间复杂度为

   ```C
   void fun(int n)
   {
       int i = 0;
       while (i*i*i <= n)
           i++;
   }
   ```

   基本运算假设基本运算i++执行t次，即有$t*t*t$ <= n，即t^3^ <= n，故t <= n^1/3^，T(n) = O(n^1/3^)。



10. 程序段如下

    ```C
    for (i = n; i > 1; i--)
        for (j = 1; j < i; j++)
            if (A[j] > A[j+1])
                A[j]与A[j+1]交换;
    ```

    其中n为正整数，则最后一行语句的频度在最坏的情况下是？

    外层循环i的值由n-1到2，内层循环由1到 i-1 ，这个程序来自冒泡排序，每次将最大元素排至表尾。最坏情况下，表内全部为逆序，每次循环都需要执行最后一句，因此执行次数为t = $\displaystyle\sum_{i = 2}^{n-1}\displaystyle\sum_{j = 1}^{i-1} 1 = \displaystyle\sum_{i = 2}^{n-1} i-1= 1+2+3+...+(n-2) = [1+(n-2)]*(n-2)*1/2 = O(n^2)$

11. 以下算法中加下划线的语句的执行次数是

    ```C
    int m = 0, i, j;
    for (i = 1; i <= n; i++)
        for (j = 1; j <= 2*i; j++)
            m++;
    ```

    外层循环由1到n，内层循环由1到2i，因此执行次数$t = \displaystyle\sum_{i = 1}^{n}\displaystyle\sum_{j = 1}^{2i} 1 = \displaystyle\sum_{i = 1}^{n}2i = 2\displaystyle\sum_{i = 1}^{n}i = 2(1+2+...+n) = (1+n)*n$

12. 下面说法错误的是

    A. 算法原地工作的含义是指不需要任何额外的辅助空间

    B. 在相同规模n下，复杂度为O(n)的算法在时间上总是由于复杂度为O(2^n^)的算法

    C. 所谓时间复杂度，是指在最坏情况下估算算法执行时间的一个上界

    D. 同一个算法，实现语言的级别越高，执行效率越低。

    算法原地工作的含义是指所需的额外辅助空间为常量，A错误

    时间复杂度为渐进时间复杂度，==不可想当然给n赋予一个特殊值==，因此时间复杂度为O(n)的算法在时间上必然优于复杂度为O(2^n^)的算法。B正确

    C显然正确

    D为严蔚敏教材的原话，此处认为结论正确。



13. 设n是描述问题规模的非负整数，下面程序段的时间复杂度是

    ```C
    x = 0;
    while (n >= (x+1)*(x+1))
        x = x+1;
    ```

    假设第t次循环终止，当第t次时有(x+1)^2^ > n，且第一次x为0，所以第t次有x = t - 1，故有t^2^ > n，即t > n^1/2^，即O(n^1/2^)。



二、综合题

1. 一个算法所需时间由下述递归方程表示，$T(n) = \begin{cases} 1,n = 1\\2T(n/2)+n, n>1\end{cases}$ ，式中n是问题规模，简单起见设n为2的整数次幂。试求出该算法的时间复杂度的级别（或阶）。

   解：由题意设n = 2^k^，k >= 0，因此$T(n)=T(2^k)=2T(2^{k-1}) + 2^k = 2[2T(2^{k-2}) +2^{k-1}] + 2^k = 2^2*T(2^{k-2}) +2*2^k = ... = 2^i*T(2^{k-i}) +i2^k = 2^k*T(1) + k*2^k = (1+k)*2^k$ 即由k = log~2~n，得T(n) = (1+log~2~n)*n = O(nlog~2~n)。



2. 分析个程序段，求出算法的时间复杂度。

   A.

   ```C
   i = 1; k = 0;
   while (i < n-1)
   {
       k = k+10*i;
       i++;
   }
   ```

   每次循环 i 递增1，因此执行次数t = n-2，所以时间复杂度为O(n)。

   B. 

   ```C
   y = 0;
   while ((y+1)*(y+1) <= n)
       y = y+1;
   ```

   每次循环y的值递增1，设总共执行t次循环，故最终t = y，于是t^2^ <= n，即t <= n^1/2^，T(n) = O(n^1/2^)。

   C. 

   ```C
   for (i = 1; i <= n; i++)
       for (j = 1; j <= i; j++)
           for (k = 1; k <= j; k++)
               x++;
   ```

   最外层循环 i 由1到n，第二层循环 j 由1到 i，第三层循环k由1到 j，因此x自增语句执行次数$t = O(\displaystyle\sum_{i = 1}^{n}\displaystyle\sum_{j = 1}^{i}\displaystyle\sum_{k = 1}^{j} 1) =O(\displaystyle\sum_{i = 1}^{n}\displaystyle\sum_{j = 1}^{i}j )=O(\frac{1}{2}\displaystyle\sum_{i = 1}^{n}(1+i)*i) = O(\displaystyle\sum_{i = 1}^{n}i^2) = O(1^2 +2^2+...+n^2) = O(\frac{n*(1+n)*(2n+1)}{6}) = O(n^3) $ 

   D. 

   ```C
   for (i = 0; i < n; i++)
       for (j = 0; j < m; j++)
           a[i][j] = 0;
   ```

   外层循环执行n次，内层循环执行m次，因此时间复杂度为O(m*n)。