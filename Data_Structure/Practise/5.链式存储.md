一、选择题

1. 关于线性表的顺序存储结构和链式存储结构的描述中，正确的有

   A. 线性表的顺序存储结构优于其链式存储结构。

   B. 链式存储结构比顺序存储结构能更方便地表示各种逻辑结构。

   C. 若频繁使用插入和删除结点操作，则顺序存储结构更优于链式存储结构。

   D. 顺序存储结构和链式存储结构都可以进行顺序存取。
   
   A错误，不能简单地说谁好谁坏
   
   B正确，链式存储用指针表示逻辑结构，指针是任意的，可以很方表地表示给中逻辑结构
   
   C错误，显然链式存储更适合频繁插入和删除结点
   
   D正确，两种都可以进行顺序存取，同时顺序存储结构还可以随机存取
   
   
   
2. 对于一个线性表，既要求能够进行较快速的插入和删除，又要求存储结构能够反映数据之间的逻辑，则应该用（）

   A. 顺序存储方式

   B. 链式存储方式

   C. 散列存储方式

   D. 以上均可

   选B。快速插入删除首先可以排除A和C。同时D显然不对。

   

3. 对于顺序存储的线性表，其算法时间复杂度为O(1)的运算是

   A. 将n个元素从小到大排列

   B. 删除第i个（1 <= i <= n）元素

   C. 改变第i个（1 <= i <= n）元素的值

   D. 在第i个（1 <= i <= n）元素后插入一个新元素

   选C，顺序存储可以随机读取，但删除或插入元素的时间复杂度为O(n)。

   

4. 下列关于线性表说法中，正确的是（）

   A. 顺序存储方式只能用于存储线性结构

   B. 取线性表的第i个元素的时间与i的大小有关

   C. 静态链表需要分配较大的连续空间，插入和删除不需要移动元素

   D. 在一个长度为n的有序单链表中插入一个新节点并仍保持有序的时间复杂度为O(n)

   E. 若用单链表来表示队列，则应该选用带尾指针的循环链表

   A错误，顺序存储方式同样适合图和树。

   B错误，线性表采用顺序存储时， 所需时间与i无关。

   C正确，是静态链表的特点。

   D正确，插入时间复杂度为O(1)，但找到前驱结点的时间复杂度为O(n)。

   E正确，队列需要在表头删除，表尾插入，因此带尾指针的循环链表符合要求。

   

5. 设线性表中有2n个元素，（ ）在单链表上实现要比在顺序表上实现效率更高

   A. 删除所有值为x的元素

   B. 在最后一个元素的后面插入一个新元素

   C. 顺序输出前k个元素

   D. 交换第i个元素和第2n-i-1个元素的值

   选A，对于单链表而言，插入删除结点时间复杂都为O(1)，需要完整遍历线性表，因此顺序存储和链式存储都为O(n)，但顺序存储需要移动大量元素。B、D顺序表更高效，C无区别。

   

6. 在一个单链表中，已知q所指结点是p所指节点的前驱节点，若在q和p之间插入结点s，则执行（ ）

   A. `s->next = p->next; p->next = s;`

   B. `p->next = s->next; s->next = p;`

   C. `q->next = s; s->next = p;`

   D. `p->next = s; s->next = q;`

   选C。显然。

   

7. 给定有n个元素的一维数组，建立一个有序单链表的最低时间复杂度是（ ）

   A. O(1)

   B. O(n)

   C. O(n^2^)

   D. O(nlog~2~n)

   选D。如果先建立链表，然后依次有序插入，则时间复杂度为O(n^2^)。若先对数组进行排序，排序的最好时间复杂度为O(nlog~2~n)，依次插入链表，插入时间复杂度为O(n)，总时间复杂度为O(nlog~2~n)。

   

8. 将长度为n的单链表链接在长度为m的单链表后面，其算法的时间复杂度为（ ）

   A. O(1)

   B. O(n)

   C. O(m)

   D. O(n + m)

   选C。需要找到长度为m的单链表的最后一个结点，然后才能将长度为n的单链表链接至表尾，因此时间复杂度为O(m)

   

9. 单链表中，增加一个头结点的目的是（ ）

   A. 使单链表至少有一个结点

   B. 标识表结点中首结点的位置

   C. 方便运算的实现

   D. 说明单链表使线性表的链式存储结构

   选C。单链表设置头结点的目的使为了方便运算的实现。主要好处有：1）有头结点后，插入和删除数据元素的算法就统一了，不需要再判断是否在第一个元素之前插入或删除。2）不论链表是否为空，其头指针使指向头节点的非空指针，链表的头指针不变，因此空表和非空表的处理也就统一了。

   

10. 在一个长度为n的带头结点的单链表h上，设有尾指针r，则执行（ ）操作与链表的表长有关。

    A. 删除单链表中的第一个元素

    B. 删除单链表中最后一个元素

    C. 在单链表第一个元素前插入一个新元素

    D. 在单链表最后一个元素后插入一个新元素

11. 对于一个头指针为head的带头结点的单链表，判定该表为空表的条件是（ ）；对于不带头结点的单链表，判定空表的条件为（ ）

    A. `head == NULL`

    B. `head->next == NULL`

    C. `head->next == head`

    D. `head != NULL`

    第一个空选B，第二个空选A。显然。

    

12. 下面关于线性表的一些说法中，正确的是（ ）

    A. 对于一个设有头指针和尾指针的单链表执行删除最后一个元素的操作与链表长度无关

    B. 线性表中每个元素都有一个直接前驱和一个直接后继

    C. 为了方便插入和删除数据，可以使用双链表存放数据

    D. 取线性表第i个元素的时间与i的大小有关

    选C。

    A显然错误，删除最后一个元素需要从头指针遍历至最后一个元素的前驱元素。因此时间复杂度为O(n)。

    B显然错误，第一个元素没有前驱元素，最后一个元素没有后继元素。

    D显然错误，顺序存储方式下，取第i元素的时间与i无关。

    

13. 在双链表中向p所指的结点之前插入一个结点q的操作为（ ）

    A. `p->prior = q; q->next = p; p->prior->next = q; q->prior = p->prior;`

    B. `q->prior = p->prior; p->prior->next = q; q->next = p; p->prior = q->next;`

    C. `q->next = p; p->next = q; q->prior->next = q; q->next = p;`

    D. `p->prior->next = q; q->next = p; q->prior = p->prior; p->prior = q;`



14. 在双向链表存储结构中，删除p所值的结点时必须修改指针（ ）

    A. `p->llink->rlink = p->rlink; p->rlink->llink = p->llink;`

    B. `p->llink = p->llink->llink; p->llink->rlink = p;`

    C. `p->rlink->llink = p; p->rlink = p->rlink->rlink;`

    D. `p->rlink = p->llink->llink; p->llink = p>rlink->rlink;`



15. 一直一个带有表头结点的双向循环链表L，节点结构为|prev|data|next|，其中prev和next分别是指向其直接前驱和直接后继结点的指针。现要删除指针p所指的结点，正确的语句序列是（ ）

    A. `p->next->prev = p->prev; p->prev->next = p->prev; free(p);`

    B. `p->next->prev = p->next; p->prev->next = p->next; free(p);`

    C. `p->next->prev = p->next; p->prev->next = p->prev; free(p);`

    D. `p->next->prev = p->prev; p->prev->next = p->next; free(p);`



16. 在长度为n的有序单链表中插入一个新节点，并仍然保持有序的时间复杂度是（ ）

    A. O(1)

    B. O(n)

    C. O(n^2^)

    D. (nlog~2~n)



17. 与单链表相比，双链表的优点之一是（ ）

    A. 插入、删除操作更方便

    B. 可以进行随机访问

    C. 可以省略表头指针或表尾指针

    D. 访问前后相邻节点更灵活



18. 带头结点的双循环链表L为空的条件是（ ）

    A. `L->prior == L && L->next == NULL`
    
    B. `L->prior == NULL && L->next == NULL`
    
    C. `L->prior == NULL && L->next == L`
    
    D. `L->prior == L && L->next == L`



19. 一个链表最常用的操作是在末尾插入节点和删除节点，则选用（ ）最节省时间。

    A. 带头结点的双循环链表

    B. 单循环链表

    C. 代为指针的单循环链表

    D. 单链表



20. 设对n（n>1）个元素的线性表的运算只有4种：删除第一个元素；删除最后一个元素；在第一个元素之前插入新元素；在最后一个元素之后插入新元素。最好使用（ ）

    A. 只有尾结点指针没有头结点指针的循环单链表

    B. 只有尾结点指针没有头结点指针的非循环双链表

    C. 只有头结点指针没有尾结点指针的循环双链表

    D. 既有头结点指针又有尾结点指针的循环单链表



21. 一个链表最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则选用（ ）最节省时间

    A. 不带头结点的单循环链表

    B. 双链表

    C. 不带头结点且有尾指针的单循环链表

    D. 单链表



22. 静态链表种指针表示的是（ ）

    A. 下一元素的地址

    B. 内存储器地址

    C. 下一个元素在数组中的位置

    D. 左链或右链指向的元素的地址



23. 已知表头元素为C的单链表在内存种的存储状态如下所示

    | 地址  | 元素 | 链接地址 |
    | :---: | :--: | :------: |
    | 1000H |  a   |  1010H   |
    | 1004H |  b   |  100CH   |
    | 1008H |  c   |  1000H   |
    | 100CH |  d   |   NULL   |
    | 1010H |  e   |  1004H   |
    | 1014H |      |          |

    现将f存放于1014H处，并插入单链表，若f在逻辑上位于a和e之间，则a，e，f的”链接地址“依次是（ ）

    A. 1010H, 1014H, 1004H

    B. 1010H, 1004H, 1014H

    C. 1014H, 1010H, 1004H

    D. 1014H, 1004H, 1010H



24. 需要分配较大空间，插入和删除不需要移动元素的线性表，其存储结构为（ ）

    A. 单链表

    B. 静态链表

    C. 顺序表

    D. 双链表



25. 某线性表用带头结点的循环单链表存储，头指针为head，当`head->next->next = head`成立时，线性表长度可能是（ ）

    A. 0			B. 1			C. 2			D. 可能为0或1





二、综合题

1. 设计一个递归算法，删除不带头结点的单链表L种所有值为x的结点。

2. 在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点不唯一，试编写算法以实现上述操作。

3. 设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。

4. 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小值结点时唯一的）

5. 试编写算法将带头结点的单链表就地逆置，所谓”就地“是指辅助空间复杂度为O(1)。

6. 有一个带头结点的单链表L，设计一个算法使其元素递增有序。

7. 设在一个带表头结点的单链表中所有元素结点的数据值无序，试编写一个函数，删除表中所有介于给定的两个值（作为函数参数给出）之间的元素（若存在）。

8. 给定两个单链表，编写算法找出两个链表的公共节点。

9. 给定一个带表头结点的单链表，设head为头指针，结点结构为（data, next），data为整型元素，next为指针，试写出算法：按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间（要求：不允许使用数组作为辅助空间）。

10. 将一个带头结点的单链表A分解为两个带头结点的单链表A和B，使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持其相对顺序不变。

11. 设C = {${a_1, b_1, a_2, b_2, ..., a_n, b_n}$}为线性表，采用带头结点的hc单链表存放，设计一个就地算法，将其拆分为两个线性表，使得A = {$a_1, a_1, ..., a_n$}，B= {$b_n, ..., b_2, b_1$}

12. 在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为单链表，设计算法去掉数值相同的元素，使表中不再有重复的元素，例如（7, 10, 10, 21, 30, 42, 42, 42, 51, 70）将变为（7, 10, 21, 30, 42, 51, 70）。

13. 假设有两个按元素值递增次序排列的线性表，均以单链表形式存储。请编写算法将这两个单链表归并为一个按元素值递减次序排列的单链表，并要求利用原来两个单链表的结点存放归并后的单链表。

14. 设A和B时两个单链表（带头结点），其中元素递增有序。设计一个算法从A和B中的公共元素产生单链表C，要求不破坏A、B的结点。

15. 已知两个链表A和B分别表示两个集合，其元素递增排序。编制函数，求A与B的交集，并存放于A链表中。

16. 两个整数序列A = $a_1, a_2, ..., a_m$和B = $b_1, b_2, ..., b_n$已经存入两个单链表中，设计一个算法，判断序列B是否是A的连续子序列。

17. 设计一个算法用于判断带头结点的循环双链表是否对称。

18. 有两个循环单链表，表头指针分别为h1和h2，编写一个函数将链表h2链接到链表h1之后，要求链接后的链表仍保持循环链表形式。

19. 设有一个带头结点的循环单链表，其结点值均为正整数。设计一个算法，反复找出单链表中节点值最小的结点并输出，然后将该结点从中删除，直到单链表空为止，在删除表头结点。

20. 设头结点为L的带有表头结点的非循环双向链表，其每个结点中处有pred（前驱指针），data（数据）和next（后继指针）域外，还有一个访问频度域freq。在链表被启用前，其值均初始化为零。每当在链表中进行一次Locate(L, x)运算时，令元素值为x的结点中freq域的值增1，并使此链表中结点保持按访问频度非增（递减）的顺序排列，同时最近访问的结点排在频度相同的节点前面，以便使拼房访问的结点总时靠近表头。试编写符合上述要求的Locate(L, x)运算的算法，该运算过程为函数过程，返回找到结点的地址，该类型为指针型。

21. 一直一个带有表头结点的单链表，结点结构为|data|link|，设该链表值给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0。要求：

    1）描述算法的基本设计思想

    2）描述算法的详细实现步骤

    3）根据设计思想和实现步骤，采用程序设计语言描述算法，关键之处给出简要注释

22. 假定采用带头节点的单链表保存单词，当两个单词有相同的后缀时，可共享相同的后缀存储空间，例如，"loading"和"being"的存储影响如下图所示。

    <img src=".\存储映像.jpg" alt="存储映像" style="zoom:15%;" />

    设str1和str2分别指向两个单词所在单链表的头结点，链表结构为|data|next|，请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置（如图中i所在结点的位置p）。要求：

    1）给出算法的基本设计思想

    2）根据设计思想，采用程序设计语言描述算法

    3）说明所设计算法的时间复杂度

23. 用单链表保存m个整数，结点的结构为[data] [link]，且|data| <= n (n为正整数)。现要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如给定的单链表head如下：

    head --> 21 --> -15 --> -7 --> 15

    则删除后的结点为

    head --> 21 --> -15 --> -7

    要求：

    1）给出算法的基本设计思想

    2）采用程序设计语言，给出单链表结点的数据类型定义

    3）根据设计思想，采用程序设计语言描述算法，关键之处给出注释

    4）说明所设计算法的时间复杂度和空间复杂度

24. 设计一个算法完成以下功能：判断一个链表是否有环，如果有，找出环的入口点并返回，否则返回NULL。

25. 设线性表$L = (a_1, a_2, a_3, ..., a_{n-2}, a_{n-1}, a_n)$采用带头结点的单链表保存，链表中的结点定义如下：

    ```C
    typedef struct node
    {
        int data;
        struct node *next;
    }NODE;
    ```

    请设计一个空间复杂度为O(1)且时间上尽可能高效的算法，重新排列L中的各结点，得到线性表$L' = (a_1, a_n, a_2, a_{n-1}, a_3, a_{n-2}, ...)$，要求：

    1）给出算法的基本设计思想

    2）根据设计思想，采用程序设计语言描述算法，关键之处给出注释

    3）说明所设计的算法的时间复杂度

